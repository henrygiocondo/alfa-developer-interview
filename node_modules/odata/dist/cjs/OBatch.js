"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OBatch = void 0;
var tslib_1 = require("tslib");
var ORequest_1 = require("./ORequest");
var CRLF = "\r\n";
var OBatch = /** @class */ (function () {
    function OBatch(resources, config, query, changeset) {
        var _this = this;
        if (changeset === void 0) { changeset = false; }
        this.changeset = changeset;
        // "" here prevents 'undefined' at start of body under some conditions.
        this.batchBody = "";
        this.batchConfig = tslib_1.__assign(tslib_1.__assign({}, config), config.batch);
        this.batchUid = this.getUid();
        this.batchConfig.headers.set("Content-Type", "multipart/mixed;boundary=" + this.batchUid);
        if (this.batchConfig.batch.useChangset) {
            resources = this.checkForChangset(resources, query);
        }
        else {
            this.batchBody += "--" + this.batchUid;
        }
        resources.forEach(function (req) { return req.config.method === "GET" && req.applyQuery(query); });
        var contentId = 0;
        this.batchBody += resources.map(function (req) {
            contentId++;
            return [
                "",
                "Content-Type: application/http",
                "Content-Transfer-Encoding: binary",
                "Content-ID: " + contentId,
                "",
                req.config.method + " " + _this.getRequestURL(req) + " HTTP/1.1",
                "" + _this.getHeaders(req),
                "" + _this.getBody(req)
            ].join(CRLF);
        }).join(CRLF + "--" + this.batchUid);
        this.batchBody += CRLF + "--" + this.batchUid + "--" + CRLF;
    }
    OBatch.prototype.fetch = function (url) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var req, res, data, error, ex_1;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        req = new ORequest_1.ORequest(url, tslib_1.__assign(tslib_1.__assign({}, this.batchConfig), { body: this.batchBody, method: "POST" }));
                        return [4 /*yield*/, req.fetch];
                    case 1:
                        res = _a.sent();
                        if (!(res.status === 200)) return [3 /*break*/, 3];
                        return [4 /*yield*/, res.text()];
                    case 2:
                        data = _a.sent();
                        return [2 /*return*/, this.parseResponse(data, res.headers.get("Content-Type"))];
                    case 3:
                        _a.trys.push([3, 5, , 6]);
                        return [4 /*yield*/, res.json()];
                    case 4:
                        error = _a.sent();
                        throw { res: res, error: error };
                    case 5:
                        ex_1 = _a.sent();
                        throw res;
                    case 6: return [2 /*return*/];
                }
            });
        });
    };
    OBatch.prototype.parseResponse = function (responseData, contentTypeHeader) {
        var _this = this;
        var headers = contentTypeHeader.split("boundary=");
        var boundary = headers[headers.length - 1];
        var splitData = responseData.split("--" + boundary);
        splitData.shift();
        splitData.pop();
        var parsedData = splitData.map(function (data) {
            var dataSegments = data.trim().split("\r\n\r\n");
            if (dataSegments.length === 0 || dataSegments.length > 3) {
                // we are unable to parse -> return all
                return data;
            }
            else if (dataSegments.length === 3) {
                // if length >= 3 we have a body, try to parse if JSON and return that!
                try {
                    var parsed = JSON.parse(dataSegments[2]);
                    var hasFragment = parsed[_this.batchConfig.fragment];
                    return hasFragment || parsed;
                }
                catch (ex) {
                    return dataSegments[2];
                }
            }
            else {
                // it seems like we have no body, return the status code
                return +dataSegments[1].split(" ")[1];
            }
        });
        return parsedData;
    };
    /**
     * If we determine a changset (POST, PUT, PATCH) we initalize a new
     * OBatch instance for it.
     */
    OBatch.prototype.checkForChangset = function (resources, query) {
        var changeRes = this.getChangeResources(resources);
        if (this.changeset) {
            this.batchBody += [
                "",
                "Content-Type: multipart/mixed;boundary=" + this.batchUid,
                "",
                "--" + this.batchUid
            ].join(CRLF);
        }
        else if (changeRes.length > 0) {
            this.batchBody = "--" + this.batchUid;
            this.batchBody += new OBatch(changeRes, this.batchConfig, query, true).batchBody;
            resources = this.getGETResources(resources);
        }
        else {
            this.batchBody = "--" + this.batchUid;
        }
        return resources;
    };
    OBatch.prototype.getGETResources = function (resources) {
        return resources.filter(function (req) { return req.config.method === "GET"; });
    };
    OBatch.prototype.getChangeResources = function (resources) {
        return resources.filter(function (req) { return req.config.method !== "GET"; });
    };
    OBatch.prototype.getBody = function (req) {
        if (req.config.body) {
            return "" + req.config.body + CRLF + CRLF;
        }
        return "";
    };
    OBatch.prototype.getUid = function () {
        var d = new Date().getTime();
        var uuid = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
            var r = (d + Math.random() * 16) % 16 | 0;
            d = Math.floor(d / 16);
            return (c === "x" ? r : (r & 0x7) | 0x8).toString(16);
        });
        return "" + (this.changeset
            ? this.batchConfig.batch.changsetBoundaryPrefix
            : this.batchConfig.batch.boundaryPrefix) + uuid;
    };
    OBatch.prototype.getHeaders = function (req) {
        // Request headers can be Headers | string[][] | Record<string, string>.
        // A new Headers instance around them allows treatment of all three types
        // to be the same. This also applies security last two could bypass.
        var headers = new Headers(req.config.headers || undefined);
        // Convert each header to single string.
        // Headers is iterable. Array.from is needed instead of Object.keys.
        var mapped = Array.from(headers).map(function (_a) {
            var k = _a[0], v = _a[1];
            return k + ": " + v;
        });
        if (mapped.length) {
            // Need to ensure a blank line between HEADERS and BODY. When there are
            // headers, it must be added here. Otherwise blank is added in ctor.
            mapped.push("");
        }
        return mapped.join(CRLF);
    };
    OBatch.prototype.getRequestURL = function (req) {
        var href = req.url.href;
        if (this.batchConfig.batch.useRelativeURLs) {
            // Strip away matching root from request.
            href = href.replace(this.batchConfig.rootUrl.href, '');
        }
        return href;
    };
    return OBatch;
}());
exports.OBatch = OBatch;
//# sourceMappingURL=OBatch.js.map